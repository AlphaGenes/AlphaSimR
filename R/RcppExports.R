# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

AlphaFormatter <- function() {
    .Call('AlphaSimR_AlphaFormatter', PACKAGE = 'AlphaSimR')
}

gebvRR <- function(RRsol, pop) {
    .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
}

gebvGCA <- function(GCAsol, pop, female) {
    .Call('AlphaSimR_gebvGCA', PACKAGE = 'AlphaSimR', GCAsol, pop, female)
}

gebvSCA <- function(SCAsol, pop) {
    .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', SCAsol, pop)
}

#' @title Solve Univariate Model
#' 
#' @description
#' Solves a univariate mixed model of form \deqn{y=X\beta+Zu+e}.
#'
#' @param y a matrix with n rows and 1 column
#' @param X a matrix with n rows and x columns
#' @param Z a matrix with n rows and m columns
#' @param K a matrix with m rows and m columns
#'
#' @export
solveUVM <- function(y, X, Z, K) {
    .Call('AlphaSimR_solveUVM', PACKAGE = 'AlphaSimR', y, X, Z, K)
}

#' @title Solve Multivariate Model
#' 
#' @description
#' Solves a multivariate mixed model of form \deqn{Y=X\beta+Zu+e}.
#'
#' @param Y a matrix with n rows and q columns
#' @param X a matrix with n rows and x columns
#' @param Z a matrix with n rows and m columns
#' @param K a matrix with m rows and m columns
#' @param tol tolerance for convergence
#'
#' @export
solveMVM <- function(Y, X, Z, K, tol = 1e-6) {
    .Call('AlphaSimR_solveMVM', PACKAGE = 'AlphaSimR', Y, X, Z, K, tol)
}

objWeights <- function(x, ptrData) {
    .Call('AlphaSimR_objWeights', PACKAGE = 'AlphaSimR', x, ptrData)
}

#' @title Solve Multikernel Model
#' 
#' @description
#' Solves a univariate mixed model with multiple random effects.
#'
#' @param y a matrix with n rows and 1 column
#' @param X a matrix with n rows and x columns
#' @param Zlist a list of Z matrices
#' @param Klist a list of K matrices
#'
#' @export
solveMKM <- function(y, X, Zlist, Klist) {
    .Call('AlphaSimR_solveMKM', PACKAGE = 'AlphaSimR', y, X, Zlist, Klist)
}

callRRBLUP <- function(y, x, reps, genoTrain, nMarker) {
    .Call('AlphaSimR_callRRBLUP', PACKAGE = 'AlphaSimR', y, x, reps, genoTrain, nMarker)
}

callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker) {
    .Call('AlphaSimR_callRRBLUP_MV', PACKAGE = 'AlphaSimR', Y, x, reps, genoTrain, nMarker)
}

callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker) {
    .Call('AlphaSimR_callRRBLUP_GCA', PACKAGE = 'AlphaSimR', y, x, reps, genoFemale, genoMale, nMarker)
}

callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker) {
    .Call('AlphaSimR_callRRBLUP_SCA', PACKAGE = 'AlphaSimR', y, x, reps, genoFemale, genoMale, nMarker)
}

getGeno <- function(geno, lociPerChr, lociLoc) {
    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
}

getDomGeno <- function(geno) {
    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
}

getHaplo <- function(geno, lociPerChr, lociLoc) {
    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
}

getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
}

getGvA <- function(trait, pop) {
    .Call('AlphaSimR_getGvA', PACKAGE = 'AlphaSimR', trait, pop)
}

getGvAG <- function(trait, pop, z) {
    .Call('AlphaSimR_getGvAG', PACKAGE = 'AlphaSimR', trait, pop, z)
}

getGvAD <- function(trait, pop) {
    .Call('AlphaSimR_getGvAD', PACKAGE = 'AlphaSimR', trait, pop)
}

getGvADG <- function(trait, pop, z) {
    .Call('AlphaSimR_getGvADG', PACKAGE = 'AlphaSimR', trait, pop, z)
}

calcGenParam <- function(trait, pop) {
    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
}

getHybridGvA <- function(trait, fPop, fPar, mPop, mPar) {
    .Call('AlphaSimR_getHybridGvA', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
}

getHybridGvAG <- function(trait, fPop, fPar, mPop, mPar, z) {
    .Call('AlphaSimR_getHybridGvAG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
}

getHybridGvAD <- function(trait, fPop, fPar, mPop, mPar) {
    .Call('AlphaSimR_getHybridGvAD', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar)
}

getHybridGvADG <- function(trait, fPop, fPar, mPop, mPar, z) {
    .Call('AlphaSimR_getHybridGvADG', PACKAGE = 'AlphaSimR', trait, fPop, fPar, mPop, mPar, z)
}

cross2 <- function(fGeno, fPar, mGeno, mPar, genMaps) {
    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', fGeno, fPar, mGeno, mPar, genMaps)
}

createDH2 <- function(geno, nDH, genMaps) {
    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps)
}

popVar <- function(X) {
    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
}

mergeGeno <- function(x, y) {
    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
}

calcChrMinorFreq <- function(geno, ploidy) {
    .Call('AlphaSimR_calcChrMinorFreq', PACKAGE = 'AlphaSimR', geno, ploidy)
}

convToImat <- function(X) {
    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
}

readAF <- function(nInd, segSites, ploidy, keep, inbred) {
    .Call('AlphaSimR_readAF', PACKAGE = 'AlphaSimR', nInd, segSites, ploidy, keep, inbred)
}

tuneTraitA <- function(geno, addEff, varG) {
    .Call('AlphaSimR_tuneTraitA', PACKAGE = 'AlphaSimR', geno, addEff, varG)
}

tuneTraitAD <- function(geno, addEff, domEff, varG) {
    .Call('AlphaSimR_tuneTraitAD', PACKAGE = 'AlphaSimR', geno, addEff, domEff, varG)
}

