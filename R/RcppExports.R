# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

gebvRR <- function(RRsol, pop) {
    .Call('AlphaSimR_gebvRR', PACKAGE = 'AlphaSimR', RRsol, pop)
}

gebvGCA <- function(sol, pop, female, isSCAsol = FALSE) {
    .Call('AlphaSimR_gebvGCA', PACKAGE = 'AlphaSimR', sol, pop, female, isSCAsol)
}

gebvSCA <- function(sol, pop, isSCAsol = TRUE) {
    .Call('AlphaSimR_gebvSCA', PACKAGE = 'AlphaSimR', sol, pop, isSCAsol)
}

#' @title Read Matrix
#'
#' @description
#' Uses C++ to quickly read a matrix from a text
#' file. Requires knowledge of the number of rows
#' and columns in the file.
#'
#' @param fileName path to the file to read
#' @param rows number of rows to read in
#' @param cols number of columns to read in
#' @param sep a single character seperating data entries
#' @param skipRows number of rows to skip
#' @param skipCols number of columns to skip
#'
#' @return a numeric matrix
#'
#' @export
readMat <- function(fileName, rows, cols, sep = ' ', skipRows = 0L, skipCols = 0L) {
    .Call('AlphaSimR_readMat', PACKAGE = 'AlphaSimR', fileName, rows, cols, sep, skipRows, skipCols)
}

#' @title Solve Univariate Model
#'
#' @description
#' Solves a univariate mixed model of form \eqn{y=X\beta+Zu+e}
#'
#' @param y a matrix with n rows and 1 column
#' @param X a matrix with n rows and x columns
#' @param Z a matrix with n rows and m columns
#' @param K a matrix with m rows and m columns
#'
#' @export
solveUVM <- function(y, X, Z, K) {
    .Call('AlphaSimR_solveUVM', PACKAGE = 'AlphaSimR', y, X, Z, K)
}

#' @title Solve RR-BLUP
#'
#' @description
#' Solves a univariate mixed model of form \eqn{y=X\beta+Mu+e}
#'
#' @param y a matrix with n rows and 1 column
#' @param X a matrix with n rows and x columns
#' @param M a matrix with n rows and m columns
#'
#' @export
solveRRBLUP <- function(y, X, M) {
    .Call('AlphaSimR_solveRRBLUP', PACKAGE = 'AlphaSimR', y, X, M)
}

#' @title Solve Multivariate Model
#'
#' @description
#' Solves a multivariate mixed model of form \eqn{Y=X\beta+Zu+e}
#'
#' @param Y a matrix with n rows and q columns
#' @param X a matrix with n rows and x columns
#' @param Z a matrix with n rows and m columns
#' @param K a matrix with m rows and m columns
#' @param tol tolerance for convergence
#' @param maxIter maximum number of iteration
#'
#' @export
solveMVM <- function(Y, X, Z, K, tol = 1e-6, maxIter = 1000L) {
    .Call('AlphaSimR_solveMVM', PACKAGE = 'AlphaSimR', Y, X, Z, K, tol, maxIter)
}

#' @title Solve Multivariate RR-BLUP
#'
#' @description
#' Solves a multivariate mixed model of form \eqn{Y=X\beta+Mu+e}
#'
#' @param Y a matrix with n rows and q columns
#' @param X a matrix with n rows and x columns
#' @param M a matrix with n rows and m columns
#' @param tol tolerance for convergence
#' @param maxIter maximum number of iteration
#'
#' @export
solveRRBLUPMV <- function(Y, X, M, tol = 1e-6, maxIter = 1000L) {
    .Call('AlphaSimR_solveRRBLUPMV', PACKAGE = 'AlphaSimR', Y, X, M, tol, maxIter)
}

#' @title Solve Multikernel Model
#'
#' @description
#' Solves a univariate mixed model with multiple random effects.
#'
#' @param y a matrix with n rows and 1 column
#' @param X a matrix with n rows and x columns
#' @param Zlist a list of Z matrices
#' @param Klist a list of K matrices
#' @param maxIter maximum number of iteration
#'
#' @export
solveMKM <- function(y, X, Zlist, Klist, maxIter = 20L) {
    .Call('AlphaSimR_solveMKM', PACKAGE = 'AlphaSimR', y, X, Zlist, Klist, maxIter)
}

#' @title Solve Multikernel RR-BLUP
#'
#' @description
#' Solves a univariate mixed model with multiple random effects.
#'
#' @param y a matrix with n rows and 1 column
#' @param X a matrix with n rows and x columns
#' @param Mlist a list of M matrices
#' @param maxIter maximum number of iteration
#'
#' @export
solveRRBLUPMK <- function(y, X, Mlist, maxIter = 20L) {
    .Call('AlphaSimR_solveRRBLUPMK', PACKAGE = 'AlphaSimR', y, X, Mlist, maxIter)
}

callRRBLUP <- function(y, x, reps, genoTrain, nMarker, skip) {
    .Call('AlphaSimR_callRRBLUP', PACKAGE = 'AlphaSimR', y, x, reps, genoTrain, nMarker, skip)
}

callRRBLUP_MV <- function(Y, x, reps, genoTrain, nMarker, skip, maxIter) {
    .Call('AlphaSimR_callRRBLUP_MV', PACKAGE = 'AlphaSimR', Y, x, reps, genoTrain, nMarker, skip, maxIter)
}

callRRBLUP_GCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter) {
    .Call('AlphaSimR_callRRBLUP_GCA', PACKAGE = 'AlphaSimR', y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter)
}

callRRBLUP_SCA <- function(y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter) {
    .Call('AlphaSimR_callRRBLUP_SCA', PACKAGE = 'AlphaSimR', y, x, reps, genoFemale, genoMale, nMarker, skip, maxIter)
}

#' @title Calculate G Matrix
#'
#' @description
#' Calculates the genomic relationship matrix.
#'
#' @param X a matrix of marker genotypes scored as 0,1,2
#'
#' @return a matrix of the realized genomic relationship
#'
#' @export
calcG <- function(X) {
    .Call('AlphaSimR_calcG', PACKAGE = 'AlphaSimR', X)
}

#' @title Calculate IBS G Matrix
#'
#' @description
#' Calculates an identity-by-state genomic relationship matrix
#' based on simple matching.
#'
#' @param X a matrix of marker genotypes scored as 0,1,2
#'
#' @return a matrix of genomic relationships
#'
#' @export
calcGIbs <- function(X) {
    .Call('AlphaSimR_calcGIbs', PACKAGE = 'AlphaSimR', X)
}

#' @title Calculate Euclidean distance
#'
#' @description
#' Calculates a Euclidean distance matrix using a binomial
#' theorem trick. Results in much faster computation than the
#' \code{dist} function in package \code{stats}.
#'
#' @param X a numeric matrix
#'
#' @return a matrix of columnwise distances
#'
#' @export
fastDist <- function(X) {
    .Call('AlphaSimR_fastDist', PACKAGE = 'AlphaSimR', X)
}

#' @title Calculate Paired Euclidean distance
#'
#' @description
#' Calculates a Euclidean distance between two matrices using
#' a binomial theorem trick.
#'
#' @param X a numeric matrix
#' @param Y a numeric matrix
#'
#' @return a matrix of columnwise distances between matrices
#' X and Y
#'
#' @export
fastPairDist <- function(X, Y) {
    .Call('AlphaSimR_fastPairDist', PACKAGE = 'AlphaSimR', X, Y)
}

#' @title Calculate Gaussian Kernel
#'
#' @description
#' Calculates a Gaussian kernel using a Euclidean distance
#' matrix.
#'
#' @param D a matrix of Euclidean distances,
#' see \code{\link{fastDist}}
#' @param theta the tuning parameter
#'
#' @return a numeric matrix
#'
#' @export
gaussKernel <- function(D, theta) {
    .Call('AlphaSimR_gaussKernel', PACKAGE = 'AlphaSimR', D, theta)
}

writeASGenotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
    invisible(.Call('AlphaSimR_writeASGenotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
}

writeASHaplotypes <- function(g, locations, allLocations, snpchips, names, missing, fname) {
    invisible(.Call('AlphaSimR_writeASHaplotypes', PACKAGE = 'AlphaSimR', g, locations, allLocations, snpchips, names, missing, fname))
}

getGeno <- function(geno, lociPerChr, lociLoc) {
    .Call('AlphaSimR_getGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
}

getDomGeno <- function(geno) {
    .Call('AlphaSimR_getDomGeno', PACKAGE = 'AlphaSimR', geno)
}

getHaplo <- function(geno, lociPerChr, lociLoc) {
    .Call('AlphaSimR_getHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc)
}

getOneHaplo <- function(geno, lociPerChr, lociLoc, haplo) {
    .Call('AlphaSimR_getOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo)
}

writeGeno <- function(geno, lociPerChr, lociLoc, filePath) {
    invisible(.Call('AlphaSimR_writeGeno', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, filePath))
}

writeOneHaplo <- function(geno, lociPerChr, lociLoc, haplo, filePath) {
    invisible(.Call('AlphaSimR_writeOneHaplo', PACKAGE = 'AlphaSimR', geno, lociPerChr, lociLoc, haplo, filePath))
}

getGv <- function(trait, pop) {
    .Call('AlphaSimR_getGv', PACKAGE = 'AlphaSimR', trait, pop)
}

calcGenParam <- function(trait, pop) {
    .Call('AlphaSimR_calcGenParam', PACKAGE = 'AlphaSimR', trait, pop)
}

getHybridGv <- function(trait, motherGeno, mother, fatherGeno, father) {
    .Call('AlphaSimR_getHybridGv', PACKAGE = 'AlphaSimR', trait, motherGeno, mother, fatherGeno, father)
}

cross2 <- function(motherGeno, mother, fatherGeno, father, genMaps, recombRatio) {
    .Call('AlphaSimR_cross2', PACKAGE = 'AlphaSimR', motherGeno, mother, fatherGeno, father, genMaps, recombRatio)
}

createDH2 <- function(geno, nDH, genMaps, recombRatio, useFemale) {
    .Call('AlphaSimR_createDH2', PACKAGE = 'AlphaSimR', geno, nDH, genMaps, recombRatio, useFemale)
}

crossPedigree <- function(founders, mother, father, genMaps) {
    .Call('AlphaSimR_crossPedigree', PACKAGE = 'AlphaSimR', founders, mother, father, genMaps)
}

#' @title Population variance
#' 
#' @description
#' Calculates the population variance matrix as 
#' opposed to the sample variance matrix calculated 
#' by \code{\link{var}}. i.e. divides by n instead 
#' of n-1
#' 
#' @param X an n by m matrix
#' 
#' @return an m by m variance-covariance matrix
#' 
#' @export
popVar <- function(X) {
    .Call('AlphaSimR_popVar', PACKAGE = 'AlphaSimR', X)
}

mergeGeno <- function(x, y) {
    .Call('AlphaSimR_mergeGeno', PACKAGE = 'AlphaSimR', x, y)
}

calcChrFreq <- function(geno) {
    .Call('AlphaSimR_calcChrFreq', PACKAGE = 'AlphaSimR', geno)
}

convToImat <- function(X) {
    .Call('AlphaSimR_convToImat', PACKAGE = 'AlphaSimR', X)
}

sampAllComb <- function(nLevel1, nLevel2, n) {
    .Call('AlphaSimR_sampAllComb', PACKAGE = 'AlphaSimR', nLevel1, nLevel2, n)
}

sampHalfDialComb <- function(nLevel, n) {
    .Call('AlphaSimR_sampHalfDialComb', PACKAGE = 'AlphaSimR', nLevel, n)
}

zero <- function() {
    .Call('AlphaSimR_zero', PACKAGE = 'AlphaSimR')
}

changeId <- function(newId, oldId) {
    invisible(.Call('AlphaSimR_changeId', PACKAGE = 'AlphaSimR', newId, oldId))
}

packHaplo <- function(haplo, ploidy, inbred) {
    .Call('AlphaSimR_packHaplo', PACKAGE = 'AlphaSimR', haplo, ploidy, inbred)
}

#' @title Markovian Coalescent Simulator
#' 
#' @description
#' Runs a built-in version of the Markovian Coalescent Simulator. 
#' 
#' @param args command line arguments passed to MaCS.
#' @param maxSites maximum number of segregating sites to 
#' return. If value is 0, all segregating sites are returned. 
#' Otherwise, segregating sites are randomly sampled.
#' 
#' @references
#' \cite{Chen, G.K., P. Marjoram, and J.D. Wall. 2009. Fast and flexible simulation of DNA sequence data. Genome Res. 19(1): 136–142.}
#' 
#' @return A list containing a matrix of haplotypes and a 
#' vector of genetic distances.
#'
#' @export
MaCS <- function(args, maxSites = 0L) {
    .Call('AlphaSimR_MaCS', PACKAGE = 'AlphaSimR', args, maxSites)
}

tuneTraitA <- function(geno, addEff, varG) {
    .Call('AlphaSimR_tuneTraitA', PACKAGE = 'AlphaSimR', geno, addEff, varG)
}

tuneTraitAD <- function(geno, addEff, domEff, varG, useVarA) {
    .Call('AlphaSimR_tuneTraitAD', PACKAGE = 'AlphaSimR', geno, addEff, domEff, varG, useVarA)
}

